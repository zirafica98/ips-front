import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { PaymentService } from '../../services/payment.service';
import { OrderService } from '../../services/order.service';

@Component({
  selector: 'app-payment',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './payment.component.html',
  styleUrls: ['./payment.component.scss']
})
export class PaymentComponent {
  paymentStatus: 'idle' | 'loading' | 'success' | 'fail' = 'idle';
  message = '';
  order: any;

  constructor(
    private paymentService: PaymentService,
    private orderService: OrderService
  ) {}

  ngOnInit(): void {
    this.order = JSON.parse(localStorage.getItem('currentOrder') || '{}');

    if (this.order?.id) {
      this.startPayment();
    } else {
      this.message = '‚ùå Nema aktivne porud≈æbine.';
    }
  }

  startPayment(): void {
    this.paymentStatus = 'loading';
    this.message = '‚è≥ Pokreƒáem plaƒáanje...';

    this.paymentService.createPayment(this.order.id, this.order.total).subscribe({
      next: (res) => {
        // üöÄ Oƒçekujemo plain string iz backend-a (direktni Payten link)
        let paymentUrl = typeof res === 'string' ? res : '';

        // Trim and strip surrounding quotes if present
        paymentUrl = (paymentUrl || '').trim();
        if ((paymentUrl.startsWith('"') && paymentUrl.endsWith('"')) || (paymentUrl.startsWith("'") && paymentUrl.endsWith("'"))) {
          paymentUrl = paymentUrl.slice(1, -1).trim();
        }

        // If the backend accidentally returned a JSON string like '{ "qrCodeURL": "https://..." }', try to parse it
        try {
          const maybe = JSON.parse(paymentUrl);
          if (maybe && typeof maybe === 'object') {
            paymentUrl = maybe.qrCodeURL || maybe.qrCodeUrl || maybe.qrUrl || maybe.url || maybe.paymentUrl || paymentUrl;
          }
        } catch (_) {
          // not JSON ‚Äî ignore
        }

        if (!paymentUrl) {
          this.paymentStatus = 'fail';
          this.message = '‚ùå Gre≈°ka: link za plaƒáanje nije vraƒáen.';
          return;
        }

        try {
          // If protocol is missing, assume https
          let candidate = paymentUrl;
          if (!/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(candidate)) {
            candidate = 'https://' + candidate;
          }

          const url = new URL(candidate);
          const isHttps = url.protocol === 'https:';
          const isPayten = url.hostname.endsWith('pgw.payten.com');

          if (!isHttps || !isPayten) {
            this.paymentStatus = 'fail';
            this.message = '‚ùå Gre≈°ka: neispravan link za plaƒáanje.';
            return;
          }

          // ‚úÖ Redirekcija na Payten
          window.location.replace(url.toString());
        } catch (error) {
          console.error('Invalid URL format:', error);
          this.paymentStatus = 'fail';
          this.message = '‚ùå Gre≈°ka: neispravan format URL-a.';
        }
      },
      error: (err) => {
        console.error(err);
        this.paymentStatus = 'fail';
        this.message = '‚ùå Gre≈°ka pri pokretanju plaƒáanja.';
      }
    });
  }

  checkStatus(): void {
    this.paymentStatus = 'loading';
    this.message = 'üîÑ Proveravam status plaƒáanja...';

    this.paymentService.checkPaymentStatus(this.order.id, this.order.total).subscribe({
      next: async (res) => {
        if (res.responseCode === '00') {
          this.paymentStatus = 'success';
          this.message = '‚úÖ Plaƒáanje uspe≈°no!';
          await this.orderService.updateOrderStatus(this.order.id, 'paid').toPromise();
        } else {
          this.paymentStatus = 'fail';
          this.message = '‚ùå Plaƒáanje neuspe≈°no.';
          await this.orderService.updateOrderStatus(this.order.id, 'failed').toPromise();
        }
      },
      error: async (err) => {
        console.error(err);
        this.paymentStatus = 'fail';
        this.message = '‚ùå Gre≈°ka prilikom provere.';
        await this.orderService.updateOrderStatus(this.order.id, 'error').toPromise();
      }
    });
  }
}
